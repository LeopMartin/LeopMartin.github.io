<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compte à Rebours des Bourses</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 0;
        }
        h1 {
            margin-top: 20px;
        }
        .bourse {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            display: inline-block;
            background-color: #fff;
        }
        .bourse h2 {
            margin: 0;
            font-size: 20px;
        }
        .countdown {
            font-size: 18px;
            font-weight: bold;
            color: #007BFF;
        }
    </style>
</head>
<body>
    <h1>Compte à Rebours des Horaires d'Ouverture des Bourses</h1>
    <div class="bourse" id="nyse">
        <h2>NYSE (New York)</h2>
        <div class="countdown">Calcul en cours...</div>
    </div>
    <div class="bourse" id="euronext">
        <h2>Euronext (Paris)</h2>
        <div class="countdown">Calcul en cours...</div>
    </div>
    <div class="bourse" id="tokyo">
        <h2>Tokyo Stock Exchange</h2>
        <div class="countdown">Calcul en cours...</div>
    </div>
    <div class="bourse" id="crypto-index">
        <h2>Crypto Fear & Greed Index</h2>
        <div class="countdown">Chargement en cours...</div>
    </div>
    
    <script>
        async function fetchCryptoIndex() {
            try {
                const response = await fetch("https://api.alternative.me/fng/");
                const data = await response.json();
                const value = data.data[0].value;
                const sentiment = data.data[0].value_classification;

                document.querySelector("#crypto-index .countdown").textContent =
                    `Indice : ${value} (${sentiment})`;
            } catch (error) {
                document.querySelector("#crypto-index .countdown").textContent =
                    "Erreur de chargement de l'indice.";
            }
        }

        // Appeler l'API au chargement et actualiser toutes les heures
        fetchCryptoIndex();
        setInterval(fetchCryptoIndex, 60 * 60 * 1000); // Toutes les heures


        const bourseSchedules = {
            nyse: { hours: 9, minutes: 30, timezone: "America/New_York" },
            euronext: { hours: 9, minutes: 0, timezone: "Europe/Paris" },
            tokyo: { hours: 9, minutes: 0, timezone: "Asia/Tokyo" }
        };

        function calculateTimeToOpen(schedule) {
            const now = new Date();
            // Convertir l'heure actuelle dans le fuseau horaire de la bourse
            const nowInTimezone = new Date(
                now.toLocaleString("en-US", { timeZone: schedule.timezone })
            );

            // Créer une date cible pour l'ouverture
            const target = new Date(nowInTimezone);
            target.setHours(schedule.hours, schedule.minutes, 0, 0);

            // Si l'heure actuelle dépasse l'heure cible, passer au lendemain
            if (nowInTimezone > target) {
                target.setDate(target.getDate() + 1);
            }

            // Retourner la différence en millisecondes
            return target - nowInTimezone;
        }

        function updateCountdown() {
            Object.keys(bourseSchedules).forEach(bourse => {
                const schedule = bourseSchedules[bourse];
                const timeRemaining = calculateTimeToOpen(schedule);

                // Calculer heures, minutes, secondes
                const hours = Math.floor((timeRemaining / (1000 * 60 * 60)) % 24);
                const minutes = Math.floor((timeRemaining / (1000 * 60)) % 60);
                const seconds = Math.floor((timeRemaining / 1000) % 60);

                // Mettre à jour l'affichage
                document.querySelector(`#${bourse} .countdown`).textContent =
                    `${hours}h ${minutes}m ${seconds}s`;
            });
        }

        setInterval(updateCountdown, 1000); // Mettre à jour chaque seconde.
    </script>
</body>
</html>
